"""
원-핫 인코딩은 단어를 숫자 벡터로 변환하는 가장 기본적인 방법이다.
명칭에서도 알 수 있듯이 요소들 중 단 하나의 값만 1이고 나머지 요솟값은 0인 인코딩을 의미한다.
원-핫 인코딩으로 나온 결과를 원-핫 벡터라고 하며
전체 요소 중 단 하나의 값만 1이기 때문에 희소 벡터 (sparse vector)라고 한다.

문장: 오늘 날씨는 구름이 많아요
단어 사전: ['오늘', '날씨', '구름']
인덱스 부여: [0, 1, 2]

오늘 : 0 : [1, 0, 0]
날씨 : 1 : [0, 1, 0]
구름 : 2 : [0, 0, 1]


원-핫 인코딩을 하기 위해서는
단어 집합이라고 불리는 사전을 먼저 만들어야 한다.

여기서 사전은
말뭉치에서 나오는 서로 다른 모든 단어의 집합을 의미한다.

말뭉치에 존재하는 모든 단어의 수가
원-핫 벡터의 차원을 결정한다.

예를 들어 1000개의 단어가 존재한다면
원-핫 벡터의 크기는 1000차원이 된다.

사전이 구축되었다면 사전 내 단어 순서대로
고유한 인덱스 번호를 부여한다.

단어의 인덱스 번호가 원-핫 인코딩에서
1의 값을 가지는 요소의 위치가 된다.

단어 사전 내 단어들은 각각
고유한 원-핫 벡터를 가진다.
"""


from konlpy.tag import Komoran
import numpy as np

komoran = Komoran()
text = "오늘 날씨는 구름이 많아요."

# 명사만 추출
nouns = komoran.nouns(text)
print(nouns)
# ['오늘', '날씨', '구름']

# 단어 사전 구축 및 단어별 인덱스 부여
dics = {}
for word in nouns:
    if word not in dics.keys():     # 사전에 이미 존재하는 단어가 아니라면
        dics[word] = len(dics)      # 원소 추가: key값은 단어, value값은 사전의 길이 (0부터 시작)

print(dics)
# {'오늘': 0, '날씨': 1, '구름': 2}

# 원-핫 인코딩
nb_classes = len(dics)  # 원-핫 벡터 차원의 크기 결정하기

targets = list(dics.values())
# 넘파이의 원-핫 인코딩 기능을 사용하기 위해
# 딕셔너리 타입으로 되어 있는 단어사전을
# 리스트 형태로 변환해야 한다.
# 이때 단어별 인덱스값이 필요하기 때문에
# 딕셔너리의 values() 함수를 이용해 value 값만 리스트로 변환한다.

one_hot_targets = np.eye(nb_classes)[targets]
# 원-핫 벡터를 만들기 위해서
# 넘파이의 eye() 함수를 이용한다.
# eye() 함수는 단위 행렬을 만들어 준다.

# eye() 함수 뒤에 붙은 [targets]를 이용해
# 생성된 단위행렬의 순서를
# 단어 사전의 순서에 맞게 정렬해준다.

print(one_hot_targets)
# [[1. 0. 0.]
#  [0. 1. 0.]
#  [0. 0. 1.]]

"""
원-핫 인코딩의 경우 
간단한 구현 방법에 비해 
좋은 성능을 가지기 때문에
많은 사람이 사용하고 있다.

하지만 원-핫 벡터의 경우
단순히 단어의 순서에 의한 인덱스값을 기반으로 
인코딩된 값이기 때문에
단어의 의미나 유사한 단어와의 관계를 담고있지 않다.

또한 단어 사전의 크기가 커짐에 따라 
원-핫 벡터의 차원도 커지는데
이때 메모리 낭비와 
계산의 복잡도가 커진다.

원-핫 벡터는 대부분의 요소가 0의 값을 가지고 있으므로 
비효율적이다.
"""